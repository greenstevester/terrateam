---
title: Zero-Downtime Deployments
description: How to deploy Terrateam Self-Hosted updates without downtime across all deployment methods.
slug: self-hosted/zero-downtime-deployments
---

Zero-downtime deployments ensure your Terrateam Self-Hosted instance remains available during updates. This guide covers strategies for all deployment methods.

## General Principles

All zero-downtime deployment strategies rely on these core principles:

- **Multiple instances**: Run at least two instances behind a load balancer
- **Health checks**: Use the `/health` endpoint to verify instance readiness
- **Rolling updates**: Update instances one at a time
- **Traffic draining**: Remove instances from load balancer before updating

:::note
Always test your deployment strategy in a non-production environment first.
:::

## Docker Compose Deployments

Docker Compose deployments require manual orchestration for zero-downtime updates.

### Prerequisites

- Multiple compute instances running Docker Compose with Terrateam
- Load balancer distributing traffic between instances
- Health check monitoring on `/health` endpoint

:::note
Terrateam does not recommend running Docker Compose in production. Organizations should use a container orchestration platform like Kubernetes or ECS for better scalability and reliability.
:::

### Rolling Update Process

#### 1. Drain One Instance from Load Balancer

- Mark one instance as draining in the load balancer to stop new connections
- Allow active requests to complete before proceeding

#### 2. Update Image Tag

Modify the `image` field for the drained instance:

```yaml
services:
  server:
    image: ghcr.io/terrateamio/terrat-oss:<new-tag> 
    # If using the Enterprise Edition, replace `terrat-oss` with `terrat-ee`
```

#### 3. Deploy Updated Instance

Pull the new image and restart:

```bash
docker-compose pull server
docker-compose up -d server
```

#### 4. Verify Health

Wait for the load balancer to detect the instance as healthy via `/health`, then allow traffic.

#### 5. Repeat for Remaining Instances

Repeat the process for each remaining instance, updating one at a time.

## Kubernetes Deployments

Kubernetes provides built-in support for zero-downtime deployments through rolling updates.

### Automatic Rolling Updates

Update to the latest Terrateam version:

```bash
helm repo update
helm upgrade terrateam terrateamio/terrateam
```

Helm automatically performs a rolling update, replacing pods one at a time.

### Manual Rolling Updates

For more control, update the deployment directly:

```bash
# Update image tag
kubectl set image deployment/terrateam-server server=ghcr.io/terrateamio/terrat-oss:<new-tag>

# Monitor rollout progress
kubectl rollout status deployment/terrateam-server

# Rollback if needed
kubectl rollout undo deployment/terrateam-server
```

### Configuration Updates

For configuration changes without image updates:

```bash
# Update Helm values
helm upgrade terrateam terrateamio/terrateam --set server.replicas=5

# Or restart pods to pick up new ConfigMap/Secret values
kubectl rollout restart deployment/terrateam-server
```

### Scaling for Zero Downtime

Ensure multiple replicas before updates:

```bash
# Scale up before maintenance
helm upgrade terrateam terrateamio/terrateam --set server.replicas=3

# Perform updates
helm upgrade terrateam terrateamio/terrateam --set image.tag=<new-tag>

# Scale back if needed
helm upgrade terrateam terrateamio/terrateam --set server.replicas=2
```

## Manual/Docker Deployments

Manual deployments require careful orchestration for zero-downtime updates.

### High Availability Setup

Deploy multiple instances across different hosts:

```bash
# Host 1
docker run -d --name terrateam-server-1 -p 8081:8080 [env-vars] ghcr.io/terrateamio/terrat-oss:latest

# Host 2  
docker run -d --name terrateam-server-2 -p 8082:8080 [env-vars] ghcr.io/terrateamio/terrat-oss:latest

# Host 3
docker run -d --name terrateam-server-3 -p 8083:8080 [env-vars] ghcr.io/terrateamio/terrat-oss:latest
```

### Rolling Update Process

#### 1. Remove Instance from Load Balancer

Update your load balancer configuration to stop sending traffic to the first instance.

#### 2. Update Instance

```bash
# Pull new image
docker pull ghcr.io/terrateamio/terrat-oss:latest

# Stop current container
docker stop terrateam-server-1

# Remove old container
docker rm terrateam-server-1

# Start new container
docker run -d --name terrateam-server-1 -p 8081:8080 [env-vars] ghcr.io/terrateamio/terrat-oss:latest
```

#### 3. Verify Health

Check the instance is healthy:

```bash
curl http://host1:8081/health
```

#### 4. Add Back to Load Balancer

Once healthy, add the instance back to your load balancer configuration.

#### 5. Repeat for Other Instances

Repeat the process for each remaining instance.

### Blue-Green Deployment

For even safer deployments, use blue-green strategy:

#### 1. Deploy Green Environment

Set up a complete parallel environment with the new version.

#### 2. Test Green Environment

Verify the green environment is working correctly with health checks and smoke tests.

#### 3. Switch Traffic

Update your load balancer to route traffic to the green environment.

#### 4. Monitor

Monitor the new deployment closely for any issues.

#### 5. Cleanup

Once confident in the green deployment, tear down the blue environment.

## Load Balancer Configuration

### Health Check Configuration

Configure your load balancer to use Terrateam's health endpoint:

**Nginx:**
```nginx
upstream terrateam {
    server host1:8080 max_fails=3 fail_timeout=30s;
    server host2:8080 max_fails=3 fail_timeout=30s;
    server host3:8080 max_fails=3 fail_timeout=30s;
}

server {
    location / {
        proxy_pass http://terrateam;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
    
    location /health {
        proxy_pass http://terrateam;
        access_log off;
    }
}
```

**HAProxy:**
```
backend terrateam
    balance roundrobin
    option httpchk GET /health
    http-check expect status 200
    server server1 host1:8080 check
    server server2 host2:8080 check
    server server3 host3:8080 check
```

**AWS Application Load Balancer:**
- Health check path: `/health`
- Health check port: Traffic port
- Healthy threshold: 2
- Unhealthy threshold: 3
- Timeout: 5 seconds
- Interval: 30 seconds

### Traffic Draining

Configure appropriate connection draining timeouts:

- **Nginx**: Use `proxy_read_timeout` and graceful shutdown
- **HAProxy**: Set `timeout server` appropriately
- **AWS ALB**: Configure deregistration delay (default 300 seconds)

## Database Considerations

### Database High Availability

For zero-downtime deployments, ensure your database can handle:

- **Connection pooling**: Multiple Terrateam instances connecting simultaneously
- **Schema migrations**: Backward-compatible changes during rolling updates
- **Backup during updates**: Regular backups before major version updates

### Schema Migration Strategy

When updates include database schema changes:

1. **Forward-compatible migrations**: Ensure new schema works with old application code
2. **Rolling updates**: Update application instances after schema migration
3. **Cleanup migrations**: Remove deprecated columns/tables in subsequent releases

## Monitoring During Deployments

### Key Metrics to Monitor

- **Health check status**: Monitor `/health` endpoint response times and success rates
- **Error rates**: Watch for increased error rates during deployment
- **Response times**: Ensure performance doesn't degrade
- **Active connections**: Monitor connection counts during traffic draining

### Rollback Procedures

Be prepared to rollback quickly if issues arise:

**Kubernetes:**
```bash
kubectl rollout undo deployment/terrateam-server
```

**Docker Compose:**
```bash
# Revert to previous image tag
docker-compose up -d server
```

**Manual Docker:**
```bash
# Stop current container and start previous version
docker stop terrateam-server-1
docker rm terrateam-server-1
docker run -d --name terrateam-server-1 [env-vars] ghcr.io/terrateamio/terrat-oss:<previous-tag>
```

## Testing Zero-Downtime Deployments

### Pre-Production Testing

1. **Staging environment**: Test the complete deployment process in staging
2. **Load testing**: Verify the system handles load during updates
3. **Failover testing**: Test load balancer behavior during instance failures

### Production Validation

1. **Canary deployments**: Update a small percentage of instances first
2. **Monitoring dashboards**: Watch key metrics throughout the deployment
3. **Automated rollback**: Set up automated rollback triggers for critical failures

## Best Practices

### Planning

- **Maintenance windows**: Schedule updates during low-traffic periods
- **Team coordination**: Ensure proper team communication during deployments
- **Documentation**: Keep runbooks updated with current procedures

### Execution

- **Gradual rollout**: Update instances gradually, not all at once
- **Verification**: Verify each instance before adding it back to the load balancer
- **Monitoring**: Continuously monitor during and after deployment

### Recovery

- **Rollback plan**: Always have a tested rollback procedure
- **Communication**: Establish clear communication channels for issues
- **Post-mortem**: Conduct post-deployment reviews to improve processes

## Conclusion

Zero-downtime deployments are achievable across all Terrateam deployment methods with proper planning and execution. The key is maintaining multiple healthy instances behind a load balancer and updating them incrementally while monitoring system health throughout the process.

Choose the deployment method that best fits your infrastructure and operational requirements, but always prioritize reliability and the ability to quickly recover from issues.